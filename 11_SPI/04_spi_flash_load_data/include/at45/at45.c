/** * AT45DB642D SPI FLASH operations code */#define AT45_PAGE_SIZE 1056// at45x data transferstatic void at45_transfer(void *cmd, unsigned cmd_len,    void *data, unsigned data_len) {    struct spi_t_block t_block[2];    int block_n = 1;    // setup command to transfer structure    t_block[0].spi_rx = cmd;    t_block[0].spi_tx = cmd;    t_block[0].spi_t_len = cmd_len;    // if data exists setup data to transfer structure    if (data_len) {        t_block[1].spi_rx = data;        t_block[1].spi_tx = data;        t_block[1].spi_t_len = data_len;        block_n++;    }    // select at45db642d spi flash    spi_select(0);    // transfer data    spi_transfer(t_block, block_n);}// at45x statusstatic unsigned at45_status(){	char req[2];	req[0] = 0xd7;	at45_transfer(req, sizeof(req), 0, 0);	return req[1];}// at45x waiting readystatic void at45_wait_rdy() {	while (!(at45_status() & 0x80));}// at45x page writingstatic void at45_page_write(int id, unsigned short page) {	unsigned char req[4];	req[0] = (id == 1) ? 0x83 : 0x86;	req[1] = ((page & 0x0000ff00) >> 7);	req[2] = ((page & 0x000000ff) << 1);	at45_transfer(req, 4, 0, 0);}// at45x page erasestatic int at45_page_erase(unsigned short page) {    unsigned char req[4];    req[0] = 0x81;    req[1] = ((page & 0x0000ff00) >> 7);    req[2] = ((page & 0x000000ff) << 1);        at45_transfer(req, 4, 0, 0);        at45_wait_rdy();    return 0;} // at45 buffer fillstatic void at45_buffer_fill(unsigned id, const void *in) {	unsigned char buffer[AT45_PAGE_SIZE];	unsigned char req[4];	req[0] = (id == 1) ? 0x84 : 0x87;	req[2] = 0;	req[3] = 0;	util_memcopy(buffer, in, AT45_PAGE_SIZE);	at45_transfer(req, 4, buffer, AT45_PAGE_SIZE);}// at45x initingstatic unsigned at45_init() {    unsigned char req[4];    unsigned data_len = 4;    struct spi_t_block t_block;        // Get device information    req[0] = 0x9f;        at45_transfer(req, sizeof(req), 0, 0);        util_printf("Manufacturer ID: %x\n", req[1]);    util_printf("Density Code: %x\n", req[2]);    util_printf("Product Version: %x\n", req[3]);        if (req[1] != 0x1f || req[2] != 0x28) {		util_printf("Unknown Device\n");		return -1;	}    else {        util_printf("Device is AT45DB642D\n");    }	util_printf("Status Register: %x\n", at45_status());	return 0;}// at45x reading datastatic unsigned at45_read(unsigned lba, void *ptr, unsigned len) {    unsigned short req[5];	unsigned addr, page, byte;	page = lba / AT45_PAGE_SIZE;    byte = lba % AT45_PAGE_SIZE;	addr = (page << 11) | byte;	util_printf("Reading addr = 0x%x, length = 0x%x\n",			addr, len);	req[0] = 0x0b;	req[1] = ((addr & 0x00ff0000) >> 16);	req[2] = ((addr & 0x0000ff00) >> 8);	req[3] = ((addr & 0x000000ff));	at45_transfer(req, 5, ptr, len);	return 0;}// at45x writing datastatic unsigned at45_write(unsigned lba, const void *ptr, unsigned len) {    const unsigned char *ptr8_r = ptr;	unsigned page, pg_n, z0, z1, id = 1;    // check data address and size	page = lba / AT45_PAGE_SIZE;    z0 = lba % AT45_PAGE_SIZE;	pg_n = len / AT45_PAGE_SIZE;	z1 = len % AT45_PAGE_SIZE;	if (z0 != 0)		return -1;	if (z1 != 0)		return -1;	util_printf("Writing page = 0x%x, count = 0x%x\n",			page, pg_n);	while (pg_n--) {		at45_buffer_fill(id, ptr8_r);		at45_wait_rdy();		at45_page_write(id, page++);		id = (id == 1) ? 2 : 1;		ptr8_r += AT45_PAGE_SIZE;	}	at45_wait_rdy();	return 0;}